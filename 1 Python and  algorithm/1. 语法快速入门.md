## 数据结构

python 中一切皆对象，变量只保存对数据对象的引用，通过函数 id 可以获取变量中所保存对象的内存地址

### python中的数据对象

编程语言中，变量是对内存及其地址的抽象，python通过 = 赋值操作给变量约束一个值，这里的值可以是任何对象.给变量约束一个对象，就是把对象在内存中的位置存入该变量（c 语言中变量的值直接就保存在变量的存储区内）

python 中数据对象的类型主要有；
1. 可变对象：list,dict,set
2. 不可变对象：int,string,float,tuple


```python
a = 'ABC'
b = a
a = a + 'D'
print(b)

'''结果是 'ABC', 因为在修改指向不可变对象的变量时，
会产生新的对象，再将要修改的变量重新指向新的对象。

python中所有的参数传递都是引用传递。'''
```

**基本数据类型**
1. int
2. float
3. bool
4. str

**序列数据类型**

具备： 下标访问，切片，in判断，len判断，迭代 等性质的顺序表结构

1. 列表 [1,2,3] list: 是有序的 本质是元素个数可变的动态顺序表结构，具备高效的下标访问速度，插入时使用 list 自带的 append 方法效率较高。列表中的元素可以是任何对象

2. 元祖 (1,) tuple: 本质是不变的列表

3. 字符串也是序列数据类型 本质是元素个数不变的一体式的顺序表结构

**集合类型**

基于散列表技术实现的数据结构

1. 集合{1,2,3} set 是无序的 而且集合中的元素不重复 集合中的元素只能是不变对象 不支持下标取值操作集合支持的特殊操作：
差集： {1，2，3} - {1}
交集： {1，2，3} & {1，2}
并集： {1，2，3} | {1，4} 
注意 定义空集合的方式：set() 使用 {} 是定义空字典

2. 字典 {1: 2} key：value 类型 dict 是无序的，可以通过下标Key 访问Value，dict的key只能是不可变对象，value 可以是任何对象。
```python
//字典排序 将字典转化成 元祖列表 再排序。
dict_1= {"Alice": 15, "Jerry": 35, "Wendy": 25}
sorted(dict_1.items(), key=lambda item: item[1])
```

### 代码组织结构
包（有__init__.py 的文件夹） -> 模块(py文件) -> 类（一个py文件可以有多个类） 

    主 module，也就是程序运行的入口py文件是代码运行的当前路径


#### 1. 导入方式

    import a as XX
    from package.module import xx or * 


#### 2. __init__.py 文件的作用

1. 包的初始化 与 批量导入
Python首次导入某个目录时，会自动执行该目录下__init__.py文件所有程序的代码。这类文件就是放置包类文件所需要初始化的代码的场所。


2. 模块命名空间的初始化
在包导入模型中，脚本内的目录路径，在导入后会变成真实的嵌套对象路径。比如，在包test的__init__.py中定义了a = 1，那么，在我们import test之后，可以得到
``` python
import test
test.a
```
3. 定义import * 语句的行为
可以在__init__.py中使用__all__，指定import * 的行为
```python
__all__ = ["Module1", "Module2", "subPackage1", "subPackage2"]
```

**注意:**

包和模块是不会重复导入的
导入模块时 模块中的代码都会执行

### 面向对象

python 里建立的类也是一种对象，表示一个数据类型，类确定了一个名字空间，位于类体里面的定义都局限于这个类体中。可以从类名出发，通过属性引用的方式访问有定义的属性，取得它们的值（相当于访问一个名字空间 定义的局部变量）

#### 对象的属性
每个实例的对象是一个基于类产生的新的局部名字空间，其中包含该对象的所有属性与值。

#### 对象的方法
假设p是类c的一个实例，p.m(...) 实际上等价于函数调用C.m(p, ...)

#### 方法的查找
动态语言的特性，如果从一个子类的实例对象去调用方法，需要确定应该调用哪个函数（哪个类里定义的函数） 查找过程：从实例对象所属的类开始，如果没找到就到基类去找

#### 继承
把子类看做是父类的特殊情况，会继承父类的所有功能和属性，还可以覆盖父类的功能和属性

#### 多态
动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。